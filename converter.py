import subprocess
import os
import shutil
import psutil
import math
import pathlib
import config as cfg
import importlib
import tree
import ray


# multiprocessing module ray should give better performance through shared memory, windows is not supported
ray_spec = importlib.util.find_spec("ray")
ray_available = ray_spec is not None
num_cpus = psutil.cpu_count(logical=False)
ray_init = ray.init(num_cpus=num_cpus)

# preamble preloaded in preamble.fmt, saved in preamble.tex, pdf compression set to 3
code_directory = pathlib.Path(__file__).resolve().parent
preamble = pathlib.PurePath(code_directory, 'preamble.fmt')
preamble_compiled = False

# latex expression template
template = '''%&preamble

\\begin{{document}}
\\begin{{minipage}}[c][1cm]{{50cm}}
\\centering{{
    $ {expression} $
}}
\\end{{minipage}}
\\end{{document}}'''


def precompile_preamble():
    """This function precompiles the preamble of the template and saves the .fmt file at the synthetic data folder."""

    precompile_cmd = 'pdflatex -ini -jobname="preamble" "&pdflatex preamble.tex\\dump" > ' + cfg.paths_cfg.dump
    subprocess.run(precompile_cmd, cwd=code_directory, shell=True)


@ray.remote
def process(pid, offset, sequences, directory, file_count):
    """This function calls all functions required for the full latex to png conversion for a subset of the sequences.
    It is meant to be called for a single process. The respective subset depends on the given offset.

    :param pid: The identifier of a process i with i=0,1,2,.. .
    :param offset: The subset of indices the process will process gets computed by pid * offset - (pid+1) * offset.
    :param sequences: The list of sequences that is being processed.
    :param directory: The directory path which the png files should be written to.
    :param file_count: The amount of files already in the directory. This is required to generate file names.
    :return: The return value serves as synchronization point for ray and is of no other use.
    """

    start_index = pid * offset
    end_index = (pid + 1) * offset
    end_index = min(end_index, len(sequences))

    for i in range(start_index, end_index):
        name = str(file_count + i)
        file = pdflatex(sequences[i], directory, directory + '/' + name + '.tex')
        # file = croppdf(directory, file, name)
        file = pdf2png(directory, file, name)

    return True


def convert_to_png(sequences, directory=cfg.paths_cfg.synthetic_data) -> None:
    """This function takes a batch of seqences in form of onehot encodings and converts them to the .png format.

    :param sequences: An array of size (batch size, sequence length, onehot length) is expected. This function
        assumes that the given onehot encodings in the array are valid.
    :param directory: The directory path where the png files will get saved. The function assumes the directory exists.
    """

    global num_cpus, preamble

    if not preamble_compiled:
        precompile_preamble()

    shutil.copyfile(preamble, directory + 'preamble.fmt')

    trees = tree.batch2tree(sequences)
    sequences = [t.latex() for t in trees]

    num_seqs = len(sequences)
    cpus_used = min(num_seqs, num_cpus)
    offset = math.ceil(num_seqs / cpus_used)
    file_count = len(os.listdir(directory))

    # copy to shared memory once instead of copying to each cpu
    sequences_id = ray.put(sequences)
    offset_id = ray.put(offset)
    directory_id = ray.put(directory)
    file_count_id = ray.put(file_count)

    # no need for return value but call get for synchronisation
    ray.get([process.remote(pid, offset_id, sequences_id, directory_id, file_count_id) for pid in range(cpus_used)])

    # else:
    #     def use_multiprocessing():
    #         processes = []
    #
    #         for pid in range(cpus_used):
    #             proc = multiprocessing.Process(target=process, args=(pid, offset, sequences, directory, file_count))
    #             processes.append(proc)
    #             proc.start()
    #
    #         for proc in processes:
    #             proc.join()
    #
    #     use_multiprocessing()


def clean_up(directory):
    """This function will delete anything but .png files in a given directory. It is usefull to remove auxiliary files
    that get generated by pdflatex.

    :param directory: The path to the directory that should be cleared.
    """

    with os.scandir(directory) as iterator:
        for entry in iterator:
            if entry.is_file() and not entry.name.endswith('.png'):
                os.remove(entry)


def pdflatex(expr, directory, file):
    with open(file, 'w') as f:
        f.write(template.format(expression=expr))

    cmd = ['pdflatex',
           '-interaction=batchmode',
           '-interaction=nonstopmode',
           file]

    subprocess.run(cmd, cwd=directory, stdout=subprocess.DEVNULL, timeout=2)  # errors are critical

    return file[:-3] + 'pdf'


def croppdf(directory, file, name):
    # TODO what if the concurrent access of the dump file and the logs in general requires sync??

    cmd = ('gs '
           '-dUseCropBox '
           '-dSAFER '
           '-dBATCH '
           '-dNOPAUSE '
           '-sDEVICE=pdfwrite '
           '-sOutputFile={}/crop_{}.pdf '
           '-c [/CropBox [550 0 850 100] '  # (x,y) (x',y')
           '-c /PAGES pdfmark '
           '-f {} '
           '> {}')

    cmd = cmd.format(directory, name, file, cfg.paths_cfg.dump)

    subprocess.run(cmd, cwd=directory, shell=True)  # errors are critical

    return directory + '/crop_' + name + '.pdf'


def pdf2png(directory, file, name):
    print(file)

    cmd = ['gs',
           '-dUseCropBox',
           '-dSAFER',
           '-dBATCH',
           '-dNOPAUSE',
           '-sDEVICE=png16m',
           '-r80',
           '-sOutputFile=' + name + '.png',
           file]

    subprocess.run(cmd, cwd=directory, stdout=subprocess.DEVNULL, timeout=2)  # errors are critical

    return directory + '/' + name + '.png'
