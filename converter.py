import subprocess
import os
import shutil
import psutil
import math
import pathlib
import config as cfg
import tree
import ray


# multiprocessing module ray should give better performance, windows is not supported
num_cpus = psutil.cpu_count(logical=False)

# preamble preloaded in preamble.fmt, saved in preamble.tex, pdf compression set to 3
code_directory = pathlib.Path(__file__).resolve().parent
preamble = pathlib.PurePath(code_directory, 'preamble.fmt')
preamble_compiled = False

# latex expression template
template = '''%&preamble

\\begin{{document}}
\\begin{{minipage}}[c][1cm]{{50cm}}
\\centering{{
    $ {expression} $
}}
\\end{{minipage}}
\\end{{document}}'''


def initialize_ray():
    """
    Initializes the ray module and reserves shared memory. To see how much memory it reservers, enable logging.
    Should be called exactly once at the beginning of the application.
    """

    ray.init(num_cpus=num_cpus, log_to_driver=True)


def shutdown_ray():
    """
    Should be called at the end of the application.
    """

    ray.shutdown()


def precompile_preamble():
    """
    This function precompiles the preamble of the template and saves the .fmt file at the synthetic data folder.
    """

    precompile_cmd = 'pdflatex -ini -jobname="preamble" "&pdflatex preamble.tex\\dump" > ' + cfg.paths.dump
    subprocess.run(precompile_cmd, cwd=code_directory, shell=True)


@ray.remote
def conversion(pid, offset, sequences, directory, file_count):
    """
    This function calls all functions required for the full latex to png conversion for a subset of the sequences.
    It is meant to be called for a single process. The respective subset depends on the given offset.

    :param pid: The identifier of a process i with i=0,1,2,.. .
    :param offset: The subset of indices the process will process gets computed by pid * offset - (pid+1) * offset.
    :param sequences: The list of sequences that is being processed.
    :param directory: The directory path which the png files should be written to.
    :param file_count: The amount of files already in the directory. This is required to generate file names.
    :return: The return value serves as synchronization point for ray and is of no other use.
    """

    start_index = pid * offset
    end_index = (pid + 1) * offset
    end_index = min(end_index, len(sequences))

    for i in range(start_index, end_index):
        name = str(file_count + i)
        file = pdflatex(sequences[i], directory, name)
        file = pdf2png(directory, file, name)

    return True


def convert_to_png(sequences, directory=cfg.paths.synthetic_data) -> None:
    """
    This function takes a batch of seqences or a list of batches in form of onehot encodings and converts them to
    the .png format. Lists of batches are encouraged to justify the multiprocessing overhead.

    :param sequences: An array of size (batch size, sequence length, onehot length) is expected. This function
        assumes that the given onehot encodings in the array are valid. A list of batches is also allowed.
    :param directory: The directory path where the png files will get saved. The function assumes the directory exists.
    """

    global num_cpus, preamble

    if not preamble_compiled:
        precompile_preamble()

    shutil.copyfile(preamble, directory + '/preamble.fmt')

    if isinstance(sequences, list):
        trees = []
        for batch in sequences:
            trees += tree.batch_to_tree(batch)

    else:
        trees = tree.batch_to_tree(sequences)

    sequences = [t.latex() for t in trees]

    num_seqs = len(sequences)
    cpus_used = min(num_seqs, num_cpus)
    offset = math.ceil(num_seqs / cpus_used)
    file_count = len(os.listdir(directory))

    # copy to shared memory once instead of copying to each cpu
    sequences_id = ray.put(sequences)
    offset_id = ray.put(offset)
    directory_id = ray.put(directory)
    file_count_id = ray.put(file_count)

    # no need for return value but call get for synchronisation
    ray.get([conversion.remote(pid, offset_id, sequences_id, directory_id, file_count_id) for pid in range(cpus_used)])


def clean_up(directory) -> None:
    """
    This function will delete anything but .png files in a given directory. It is usefull to remove auxiliary files
    that get generated by pdflatex.

    :param directory: The path to the directory that should be cleared.
    """

    with os.scandir(directory) as iterator:
        for entry in iterator:
            if entry.is_file() and not entry.name.endswith('.png'):
                os.remove(entry)


def pdflatex(expr, directory, name) -> str:
    """
    This function generates a .pdf file at the target location. It uses pdflatex to compile the given latex code.

    :param expr: A single latex formular string without $$ or an equation environment.
    :param directory: The directory path in which the .pdf file should be saved in.
    :param name: An unique identifier for the generated file.
    :return: Returns the full path of the generated .pdf file.
    """

    file = directory + '/' + name + '.tex'

    with open(file, 'w') as f:
        f.write(template.format(expression=expr))

    cmd = ['pdflatex',
           '-interaction=batchmode',
           '-interaction=nonstopmode',
           file]

    subprocess.run(cmd, cwd=directory, stdout=subprocess.DEVNULL, timeout=2)  # errors are critical

    return file[:-3] + 'pdf'


def pdf2png(directory, file, name) -> str:
    """
    This function generates a .png file at the target location from a given .pdf file. It uses ghostscript
    internally.

    :param directory: The directory path where the target .png file is located.
    :param file: The target .pdf file which should be converted to .png format.
    :param name: The unique identifier for the generated file.
    :return: Returns the full path to the generated .png file.
    """

    cmd = ['gs',
           '-dUseCropBox',
           '-dSAFER',
           '-dBATCH',
           '-dNOPAUSE',
           '-sDEVICE=png16m',
           '-r80',
           '-sOutputFile=' + name + '.png',
           file]

    subprocess.run(cmd, cwd=directory, stdout=subprocess.DEVNULL, timeout=2)  # errors are critical

    return directory + '/' + name + '.png'
